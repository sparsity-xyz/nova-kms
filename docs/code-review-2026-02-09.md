# Overview

Nova KMS is a distributed KMS designed to run *inside* AWS Nitro Enclaves (via Nova Platform) and expose a small HTTP API for:

- HKDF-derived per-app keys
- CSR signing via a deterministic, cluster-wide CA
- An in-memory, per-app KV store
- Inter-node anti-entropy sync (delta + snapshot)

The repo largely matches its design docs: the main “secure identity” primitive is an Ethereum wallet bound on-chain to a Nova runtime instance (NovaAppRegistry), and PoP signatures (EIP-191) are used as a lightweight request authenticator.

Where I’m opinionated: the security boundary is real, but some paths fail open (plaintext storage fallback) and some trust checks are weaker than the docs imply (peer validation relies only on KMSRegistry membership; NovaRegistry wrapper decoding looks fragile). These are fixable.

---

# Architecture & Trust Model

## Components and data flows

**Primary runtime**: a FastAPI service in [enclave/app.py](../enclave/app.py) wires up:

- `MasterSecretManager` (cluster secret + epoch) from [enclave/kdf.py](../enclave/kdf.py)
- `DataStore` (in-memory KV, per-app namespaces) from [enclave/data_store.py](../enclave/data_store.py)
- `AppAuthorizer` from [enclave/auth.py](../enclave/auth.py)
- `SyncManager` + `PeerCache` from [enclave/sync_manager.py](../enclave/sync_manager.py)
- HTTP API routes from [enclave/routes.py](../enclave/routes.py)

**On-chain identity and membership**:

- App identity + measurement + runtime instance URL are read from NovaAppRegistry via [enclave/nova_registry.py](../enclave/nova_registry.py)
- KMS node membership (operator set) is read from KMSRegistry via [enclave/kms_registry.py](../enclave/kms_registry.py)
- Both use read-only RPC via [enclave/chain.py](../enclave/chain.py), with a “finalized” read path `eth_call_finalized()` that attempts a confirmation-depth block.

**Authentication**:

- Apps authenticate to KMS using PoP headers (`X-App-*`), recovered to a signer wallet in [enclave/auth.py](../enclave/auth.py) via `app_identity_from_signature()`.
- KMS nodes mutually authenticate sync calls using PoP headers (`X-KMS-*`) in [enclave/sync_manager.py](../enclave/sync_manager.py) via `handle_incoming_sync()`.
- `/nonce` is a shared challenge endpoint in [enclave/routes.py](../enclave/routes.py) backed by `_NonceStore` in [enclave/auth.py](../enclave/auth.py).

**Key distribution**:

- The master secret is generated by the “seed” node from Odyn RNG (`MasterSecretManager.initialize_from_random()` in [enclave/kdf.py](../enclave/kdf.py)).
- New nodes request the secret from peers via `/sync` using sealed ECDH envelopes (`seal_master_secret()`/`unseal_master_secret()` in [enclave/kdf.py](../enclave/kdf.py)).

**Anti-split-brain**:

- Implemented in `SyncManager.wait_for_master_secret()` ([enclave/sync_manager.py](../enclave/sync_manager.py)).
- The documented invariant (“do not generate if an ACTIVE peer exists but is unreachable”) is followed.

## Trust boundaries

1. **Nitro Enclave boundary**: memory contents are assumed confidential/integrity-protected from the host OS. This is where the master secret and derived keys live.
2. **HTTP boundary**: all clients are untrusted; authentication is app-layer PoP.
3. **Blockchain boundary**: correctness depends on NovaAppRegistry/KMSRegistry state; [enclave/chain.py](../enclave/chain.py) attempts to reduce reorg risk using a confirmation depth.
4. **Peer boundary**: peers are only trusted if they are (a) registered operators on KMSRegistry and (b) mutually PoP-authenticated. *Integrity* of data sync is optionally strengthened via HMAC derived from the master secret.

## Implicit assumptions / invariants (some undocumented)

- **PoP is the only request authenticator in production**. There is no RA-TLS and no Nitro attestation doc verification on the HTTP path (explicitly stated in [enclave/auth.py](../enclave/auth.py)).
- **Node URLs come from on-chain instanceUrl** and are assumed to be HTTPS-reachable; URL validation is present but does not fully eliminate DNS-rebinding classes.
- **All KMS nodes in a cluster share one master secret**, so encrypted KV values replicate without re-encryption.
- **KMS nodes never submit transactions**, only read chain state (documented; reinforced in [enclave/chain.py](../enclave/chain.py)).

---

# Repository Structure Review

## enclave/

Strengths:

- Clean layering: routes → authz/authn → storage/KDF/sync → chain clients.
- Simulation mode ([enclave/simulation.py](../enclave/simulation.py)) is thoughtfully isolated and guarded from enclave execution.

Concerns:

- Some modules use shared module-level state (eg `_nonce_store` in auth, global singleton `master_secret_mgr` in app, `routes` globals). This is pragmatic but makes testing/extension harder.
- `NovaRegistry` contract wrapper decoding logic is brittle and untested against a real chain.

## contracts/

- Contains a small, well-scoped upgradeable contract [contracts/src/KMSRegistry.sol](../contracts/src/KMSRegistry.sol) and Foundry tests.
- Separation is good: registry is intentionally dumb (operator set only), leaving instance detail to NovaAppRegistry.

## tests/

- Good unit tests around data store, KDF, sync logic.
- Route tests mock everything (expected) and validate key endpoints.

Gaps:

- No integration tests against a real `web3.py` decoding path for NovaAppRegistry calls (this is likely where prod issues will occur).
- No negative tests for PoP replay, nonce exhaustion, malformed ciphertext poisoning via sync.

## scripts/, Dockerfile, Makefile

- Scripts are minimal and focused.
- Dockerfile sets `IN_ENCLAVE=true` unconditionally; that’s correct for production but can surprise developers running docker locally (simulation will refuse to start).

Operational risk:

- [enclaver.yaml](../enclaver.yaml) allows egress to **everything** (`0.0.0.0/0`, `::/0`, and `"**"`). The application-level URL validation helps, but egress policy should still be tightened for defense-in-depth.

---

# Repository Structure Review (File-by-File, Core Focus)

## enclave/

### app.py

**Purpose**: Startup wiring + lifecycle management; chooses simulation vs production; initializes KMS core components.

**Key logic**:

- `_startup_production()`:
  - waits for Helios via `wait_for_helios()`
  - loads TEE wallet from Odyn
  - initializes on-chain clients
  - calls `SyncManager.wait_for_master_secret()` to prevent split-brain
- Lifespan:
  - calls `routes.init(...)`
  - sets sync HMAC key via `sync_manager.set_sync_key(master_secret_mgr.get_sync_key())`
  - starts periodic jobs: `push_deltas()` and `peer_cache.refresh()`

**Strengths**:

- Simulation hard-blocked in real enclave.
- Sync HMAC is enabled automatically once the secret exists.

**Issues / Risks**:

- If `odyn.eth_address()` fails, startup continues with a zero wallet address. That can cascade into PoP recipient binding issues (`auth._node_wallet`) and operator checks.

**Recommendation**:

- In production, fail startup hard if `odyn.eth_address()` cannot be obtained or is the zero address.

### auth.py

**Purpose**: App authentication (PoP or dev headers) and on-chain authorization via `AppAuthorizer`.

**Key logic**:

- `_NonceStore`: one-time challenge cache
- `app_identity_from_signature()`: PoP verification for apps (message `NovaKMS:AppAuth:<nonce>:<kms_wallet>:<ts>`)
- `authenticate_app()`: production requires PoP; dev mode allows header identity
- `AppAuthorizer.verify()`: instance/app/version status + measurement validation

**Strengths**:

- Nonce single-use + timestamp window gives strong replay protection.
- Recipient wallet binding is correct and prevents signature reflection across nodes.

**Issues / Risks**:

- `_NonceStore` is unbounded. A high-rate `/nonce` requester can grow the dict indefinitely (rate limiting mitigates but doesn’t fully solve in shared-IP environments).
- The nonce store is shared between app PoP and KMS peer PoP; safe, but increases coupling and DoS blast radius.

**Recommendations**:

- Add a hard cap + eviction strategy in `_NonceStore` (eg max N active nonces, drop oldest on issue).
- Consider per-endpoint nonce namespaces if you want to reduce cross-protocol interference.

### kdf.py

**Purpose**: HKDF derivations and deterministic CA from master secret; sealed master secret transfer.

**Key logic**:

- `derive_app_key()`: HKDF-SHA256 with salt `nova-kms:app:<app_id>:epoch:<epoch>` and info `path[:context]`.
- `MasterSecretManager`: secret + epoch rotation.
- `seal_master_secret()`/`unseal_master_secret()`: ECDH (P-256) → HKDF → AES-GCM.
- `CertificateAuthority`: derives a P-256 private scalar from seed and self-signs a CA cert; signs CSRs.

**Strengths**:

- HKDF has reasonable domain separation (app_id + epoch in salt; path/context in info).
- CA scalar derivation avoids invalid curve scalars.
- Master secret exchange is never plaintext in production.

**Issues / Risks**:

- `CertificateAuthority.sign_csr()` does not restrict subject/SAN; an authorized app can request a cert for arbitrary names. If these certs are used as identity credentials elsewhere, this is dangerous.

**Recommendations**:

- If certs are meant to authenticate *the calling app*, override/validate CSR subject/SANs (eg enforce `CN=app:<app_id>` or inject a required SAN) and consider limiting EKUs.

### data_store.py

**Purpose**: In-memory per-app KV store with vector clocks, TTL, LRU eviction, and at-rest encryption using a per-app derived key.

**Key logic**:

- `_Namespace._encrypt()`/`_decrypt()` uses AES-GCM with a 12-byte random nonce prefix.
- `merge_record()` uses vector clocks for causal ordering; concurrent conflicts resolved by LWW (`updated_at_ms`).
- Rejects incoming records with wall-clock skew beyond `MAX_CLOCK_SKEW_MS`.

**Strengths**:

- Clear namespace isolation by `app_id`.
- Clock-skew rejection is a pragmatic safety feature to avoid obvious timestamp abuse.

**Issues / Risks**:

- **Fail-open encryption**: if `_get_key()` fails, `_encrypt()` stores plaintext and `_decrypt()` returns raw ciphertext as plaintext. This is dangerous if key derivation fails transiently.
- **Poisoning/DoS via sync**: `merge_record()` accepts any `value` bytes from peers; later reads will attempt AES-GCM decrypt and can raise `DecryptionError`, resulting in 500s from API calls for that key.

**Recommendations**:

- Fail closed in production: if encryption key cannot be derived, reject PUT/GET operations rather than storing plaintext.
- Validate incoming sync records before storing (minimum length, nonce prefix, and optionally attempt decrypt for sanity when key exists).
- Consider storing an explicit “encryption version” marker with each record to make format validation unambiguous.

### sync_manager.py

**Purpose**: Peer discovery, master-secret bootstrap, delta/snapshot sync, and mutual PoP + (optional) HMAC integrity.

**Key logic**:

- `PeerCache._refresh()`: `KMSRegistry.getOperators()` → `NovaRegistry.get_instance_by_wallet()` → `validate_peer_url()`
- `_make_request()`: PoP handshake (`GET /nonce` then `POST /sync`) + verifies server mutual signature
- `wait_for_master_secret()`: anti-split-brain loop
- `handle_incoming_sync()`: verifies PoP + registry membership; verifies HMAC if configured; applies deltas/snapshot; handles master secret request.

**Strengths**:

- Recipient-bound PoP is implemented as documented in [docs/kms-core-workflows.md](../docs/kms-core-workflows.md).
- HMAC uses `compare_digest` and canonical JSON serialization.

**Issues / Risks**:

- Incoming sync does not bind `body["sender_wallet"]` to the recovered PoP signer wallet; this enables spoofing sender metadata and complicates auditing.
- Peer authorization checks **only** `KMSRegistry.is_operator(wallet)` and does not check NovaAppRegistry instance status / zkVerified at sync time.
- URL validation prevents obvious private-IP SSRF, but does not defeat DNS rebinding (time-of-check vs time-of-use).

**Recommendations**:

- Enforce `sender_wallet` == recovered signer (or drop the field entirely).
- For sync, optionally require that the signer’s instance is `ACTIVE` and `zk_verified` via `NovaRegistry.get_instance_by_wallet()`.
- Consider pinning resolved IPs or restricting instance URLs to an allowlisted domain suffix.

### routes.py

**Purpose**: Exposes HTTP endpoints and wires auth/authz + KDF + KV + sync.

**Key logic**:

- `_authorize_app()` calls `authenticate_app()` then `AppAuthorizer.verify()`.
- `/nonce` issues PoP nonces.
- `/kms/derive`, `/kms/sign_cert`, `/kms/data*` are app-authenticated.
- `/sync` delegates to `SyncManager.handle_incoming_sync()`.

**Strengths**:

- Centralized authorization helper, consistent behavior across endpoints.

**Issues / Risks**:

- KV endpoints do not explicitly check that the master secret is initialized. In practice production startup blocks until initialization, but it’s still a footgun if the lifecycle changes.

**Recommendation**:

- Add an explicit master-secret readiness check for all secret-dependent endpoints (`/kms/data*`, `/kms/sign_cert`), not just `/kms/derive`.

### chain.py

**Purpose**: Provides Web3 RPC wrapper and “finalized” eth_call using confirmation depth.

**Strengths**:

- `eth_call_finalized()` is the right idea to reduce reorg-based spoofing.

**Issues / Risks**:

- Default dev RPC endpoint points to a public host; this can cause confusion and accidental reliance.

**Recommendation**:

- Prefer explicit configuration for dev endpoints; avoid surprising network calls.

### config.py

**Purpose**: Centralized configuration constants and env toggles.

**Issues**:

- `DEFAULT_TTL_MS` is 0, so TTL is effectively “off” unless callers specify.
- `ALLOWED_PEER_URL_SCHEMES` defaults to `https` only in enclave; good.

---

# Security Findings

| Issue | File/Function | Severity | Explanation | Recommendation |
|---|---|---:|---|---|
| Fail-open encryption fallback | [enclave/data_store.py](../enclave/data_store.py) (`_Namespace._encrypt`, `_Namespace._decrypt`) | High | If key derivation fails, the code stores/returns plaintext, which breaks confidentiality silently (and may lead to mixed plaintext/ciphertext states). | Fail closed in production: if `_get_key()` fails, reject KV operations; remove plaintext fallback or guard behind a dev-only flag. |
| Sync record poisoning / persistent decrypt failures | [enclave/data_store.py](../enclave/data_store.py) (`merge_record`, later `get`) | High | A malicious/buggy peer can introduce values that will later fail to decrypt and cause recurring errors for readers, turning sync into a DoS vector. | Validate incoming ciphertext format; optionally attempt decrypt for sanity before accepting; reject invalid records and log/penalize the peer. |
| Unbounded nonce store | [enclave/auth.py](../enclave/auth.py) (`_NonceStore.issue`) and [enclave/routes.py](../enclave/routes.py) (`/nonce`) | High | An attacker can request nonces indefinitely, growing memory usage without bound. | Cap active nonces and evict oldest; consider per-IP or per-wallet issuance limits and stricter rate limits on `/nonce`. |
| Sync sender wallet not bound | [enclave/sync_manager.py](../enclave/sync_manager.py) (`handle_incoming_sync`) | Medium | The PoP signature authenticates a recovered wallet, but `body.sender_wallet` can disagree; this is a footgun for logging/authorization decisions and can enable confusing audit trails. | Enforce `body.sender_wallet` equals recovered PoP wallet, or drop `sender_wallet` entirely and rely on the recovered wallet. |
| Peer validation weaker than implied | [enclave/sync_manager.py](../enclave/sync_manager.py) (`handle_incoming_sync`) | Medium | Accepting sync based solely on KMSRegistry membership ignores runtime liveness and other on-chain state (e.g., ACTIVE/zkVerified), increasing the blast radius of stale keys or registry compromise. | Add optional NovaAppRegistry checks (`get_instance_by_wallet`) for stronger liveness/auth; at minimum log and rate-limit unknown/stale operators. |
| DNS rebinding gap in URL validation | [enclave/url_validator.py](../enclave/url_validator.py) (`validate_peer_url`) and [enclave/sync_manager.py](../enclave/sync_manager.py) (`_make_request`) | Medium | A hostname that initially resolves to a safe IP can later resolve to a private/forbidden IP, potentially bypassing SSRF protections. | Pin resolved IPs per peer for a short TTL; or require IP literals; or restrict to a known domain suffix/allowlist. |
| CORS overly permissive with credentials | [enclave/app.py](../enclave/app.py) (CORS middleware) | Low | If any browser-based client ever uses cookies/credentials, wildcard origins plus credentials can create cross-site request risks depending on client behavior. | If browser clients are expected, tighten allowed origins and avoid wildcard+credentials behavior. |
| NovaRegistry ABI decoding brittleness | [enclave/nova_registry.py](../enclave/nova_registry.py) (`_call`, `get_app`, `get_version`, `get_instance_by_wallet`) | High (reliability) | Manual decode/struct handling is easy to get subtly wrong; failures here can break authZ decisions or cause confusing partial failures (even if not a direct exploit). | Add integration tests with real ABI decoding; adjust `_call` to return the expected tuple/struct shape; consider using `contract.functions.<fn>().call(...)` to avoid manual decode. |
| Deployment docs mismatch (`setAdmin`) | [docs/deployment.md](deployment.md) | Low | The emergency-ops steps reference a method that doesn’t exist on the deployed contract, which can cause delays or mistakes during incident response. | Update docs: ownership transfer is `transferOwnership` + `acceptOwnership` (Ownable2Step), not `setAdmin`. |
| Overbroad enclave egress policy | [enclaver.yaml](../enclaver.yaml) | Medium (ops) | Network-layer controls are effectively wide open, which weakens defense-in-depth against SSRF or misconfiguration. | Restrict egress to required RPC endpoints and peer domains; keep app-level SSRF defenses but add network-layer allowlists. |

---

# Smart Contract Review

## contracts/src/KMSRegistry.sol

**Purpose**: Stores the operator set for the KMS cluster. Operators are managed exclusively by NovaAppRegistry callbacks (`addOperator`/`removeOperator`).

**Integration**:

- NovaAppRegistry must be configured as the only caller (stored in `_novaAppRegistryAddr`).
- NovaAppRegistry calls `addOperator(teeWalletAddress, appId, versionId, instanceId)` on instance register; similarly removes.
- Off-chain components query `getOperators()` and verify membership.

**Access control**:

- `setNovaAppRegistry()` and `setKmsAppId()` are `onlyOwner`.
- `addOperator()` and `removeOperator()` are `onlyNovaAppRegistryMod` and enforce `appId == kmsAppId`.
- Upgrade is restricted by `_authorizeUpgrade()` to owner.

**Security notes**:

- The contract is intentionally minimal and safe.
- One operational footgun: until `kmsAppId` is set (defaults to 0), callbacks will revert for the real appId. The deployment script mentions this; but it’s easy to mis-order steps.

**Recommendations**:

- Consider an explicit “paused until configured” state to make misconfiguration obvious.
- Consider rejecting `teeWalletAddress == address(0)` defensively.

## Test coverage adequacy

- [contracts/test/KMSRegistry.t.sol](../contracts/test/KMSRegistry.t.sol) covers initialization, ownership, upgrade auth, add/remove operator semantics and lifecycle.
- Missing tests: `AppIdMismatch` revert cases, idempotency edge cases for swap-and-pop indices (though internal logic is straightforward).

---

# Testing & Reliability

## What’s covered well

- DataStore correctness and skew rejection: [tests/test_data_store.py](../tests/test_data_store.py) and [tests/test_security.py](../tests/test_security.py)
- KDF determinism and CA behavior: [tests/test_kdf.py](../tests/test_kdf.py)
- Sync core behaviors: [tests/test_sync.py](../tests/test_sync.py)
- Endpoints smoke tests: [tests/test_routes.py](../tests/test_routes.py)

## Key gaps

- No real-chain or ABI-decoding integration tests for [enclave/nova_registry.py](../enclave/nova_registry.py).
- No adversarial sync tests: invalid ciphertext injection, sender_wallet spoofing, PoP replay attempts, nonce-store exhaustion.
- No network failure tests for Helios RPC / chain RPC timeouts affecting startup.

---

# Documentation & Consistency

## Matches

- PoP formats match docs in [docs/kms-core-workflows.md](../docs/kms-core-workflows.md) and implementation in [enclave/auth.py](../enclave/auth.py) + [enclave/sync_manager.py](../enclave/sync_manager.py).
- Anti-split-brain flow in docs matches `wait_for_master_secret()`.

## Mismatches / doc bugs

- (Resolved) [docs/deployment.md](deployment.md) now uses Ownable2Step (`transferOwnership` + `acceptOwnership`) and does not reference `setAdmin`.
- (Resolved) README no longer describes `/nodes` as paginated.

---

# Maintainability

## What’s good

- Clear module boundaries and minimal complexity.
- Simulation mode is well-designed and safety-guarded.

## What will get painful as you evolve

- Global module state (`routes` globals, `_node_wallet`, `_nonce_store`, global `master_secret_mgr`) makes it harder to run multiple apps in-process or to test concurrency.
- `NovaRegistry` wrapper is a single point of failure; if decoding is wrong, auth is broken.

## How hard are key evolutions?

- Swap storage backend: moderate. DataStore API is narrow; but encryption and record format assumptions leak into sync.
- Change auth scheme: moderate. Centralized in `auth.py` and `_authorize_app()`.
- Add persistence: hard. Current design assumes volatility; persistence requires encrypted-at-rest storage, replay-safe sync, and state migration.

---

# Production Readiness Verdict

## Must fix before production

1. **DataStore fail-open encryption + sync poisoning**: this is the top security correctness issue.
2. **NovaRegistry decoding reliability**: add an integration test and fix decoding to match actual web3 behavior.
3. **Nonce store cap**: prevent memory growth DoS.
4. **Tighten enclave egress policy**: defense-in-depth.

## Acceptable technical debt (if documented)

- LWW conflict resolution with clock-skew rejection (eventual consistency tradeoff) is acceptable for a KV cache-like service, but document data-loss scenarios.
- CORS permissiveness is acceptable if you do not intend browser clients.

## Operational risks

- Startup depends on Helios and chain RPC behavior; partial failures are logged and sometimes continued. Decide if “fail open” is acceptable.
- Sync relies on `requests` without circuit-breaking/backoff. Under partitions, you can get sustained log noise and wasted CPU.

---

# Final Recommendations

1. Fail closed for all secret-dependent operations; remove plaintext fallback.
2. Validate and sanitize inbound sync records (ciphertext format, sender binding).
3. Add a real ABI-decoding test for NovaAppRegistry reads and fix `NovaRegistry._call()` accordingly.
4. Cap nonce store size; consider per-wallet/per-ip issuance throttles.
5. Tighten enclaver egress allowlist and consider domain pinning for peer URLs.
6. Clarify certificate issuance policy: treat CSRs as untrusted input; enforce naming constraints.
